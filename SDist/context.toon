constants.swift: "//\n//  constants.swift\n//  SDist\n//\n//  Created by Sal Faris on 27/02/2024.\n//\n\nimport Foundation\n\nfileprivate let URL = \"https://thesal.pythonanywhere.com\"\nfileprivate let DC = URL + \"/dc\" // DC is for Distribution Center\n\nclass Endpoints{\n    static let location = DC + \"/location?l=%@&p=%@\"\n    static let setLocation = DC + \"/location/set?k=%@&v=%@&p=%@\"\n    static let allLocation = DC + \"/location/all?p=%@\"\n    static let removeLocation = DC + \"/location/remove?k=%@&p=%@\"\n}\n\nenum CommandLineArgs: String {\n    case commandLineMode = \"-c\"\n    case passwordArg = \"-p\"\n    case functionArg = \"-f\"\n    case argumentsArg = \"-a\" // everything after this is an argument\n    case helpArg = \"-h\"\n    case cliPathArg = \"--cli-path\"\n    case errorOnNoParamsError = \"--args-only\"\n}\n\nlet documentationForFlags: [String: String] = [\n    CommandLineArgs.commandLineMode.rawValue: \"Run the CLI in command line mode\",\n    CommandLineArgs.passwordArg.rawValue: \"The password to use\",\n    CommandLineArgs.functionArg.rawValue: \"The function to run\",\n    CommandLineArgs.argumentsArg.rawValue: \"The arguments for the function, everything after this is an argument\",\n    CommandLineArgs.helpArg.rawValue: \"Show this help message\",\n    CommandLineArgs.errorOnNoParamsError.rawValue: \"If not enough parameters are given in -a, exit with an error otherwise fallbacks to interactive mode\"\n]\n\n\n\nlet WELCOME_MSG = \"Welcome to SDist CLI\"\nlet HELP_MSG = \"This CLI Tool allows you to interact with the distribution center assets.\"\n\nlet CONSTANT_MSGS_DIST_C_SERVER: [String: String] = [\n    \"ERROR_MSG\": \"INVALID\",\n    \"INVALID_PASSWORD\": \"Invalid password\",\n    \"MISSING_PARAMETER\": \"Missing parameter\",\n    \"OK\": \"OK\"\n]\n\n\nenum CLIExceptions: Error{\n    case BadPassword\n    case MissingArguments\n    case UnableToCastFunction\n}\n\n\nfunc _check_response(_ response: String?) throws -> Bool{\n    if let response = response{\n        if response == CONSTANT_MSGS_DIST_C_SERVER[\"INVALID_PASSWORD\"]{\n            throw CLIExceptions.BadPassword\n        }else if response.startswith(CONSTANT_MSGS_DIST_C_SERVER[\"ERROR_MSG\"]!){\n            print(\"An error occurred, server response:\", response)\n            return false\n        }\n    }\n    return true\n}\n"
subprocesses.swift: "//\n//  subprocesses.swift\n//  SDist\n//\n//  Created by Sal Faris on 27/02/2024.\n//\n\nimport Foundation\n\nfunc GET(url: String) -> String? {\n    let task = Process()\n    let pipe = Pipe()\n    \n    task.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n    task.arguments = [\"curl\", \"-L\", url]\n    task.standardOutput = pipe\n    \n    do {\n        try task.run()\n        let data = pipe.fileHandleForReading.readDataToEndOfFile()\n        let output = String(data: data, encoding: .utf8)\n        return output\n    } catch {\n        print(\"Error executing command: \\(error)\")\n        return nil\n    }\n}\n\nfunc downloadFile(url: String, saveName: String) {\n    let task = Process()\n    task.launchPath = \"/usr/bin/env\"\n    task.arguments = [\"curl\", \"--progress-bar\", \"-L\", \"-o\", saveName, url]\n    task.launch()\n    task.waitUntilExit()\n}\n\nfunc unzip(tempFilePath: String){\n    let task = Process()\n    task.launchPath = \"/usr/bin/unzip\"\n    task.arguments = [tempFilePath]\n    let devNull = FileHandle.nullDevice\n    task.standardOutput = devNull\n    task.standardError = devNull\n\n    task.launch()\n    task.waitUntilExit()\n}\n\nfunc mv(_ string: String, destination: String){\n    let task1 = Process()\n    task1.launchPath = \"/bin/mv\"\n    task1.arguments = [string, destination]\n    task1.launch()\n    task1.waitUntilExit()\n}\n\nfunc rm(_ string: String){\n    let task2 = Process()\n    task2.launchPath = \"/bin/rm\"\n    task2.arguments = [\"-rf\", string]\n}\n\nfunc getTerminalColumns() -> Int? {\n    let task = Process()\n    task.launchPath = \"/usr/bin/tput\"\n    task.arguments = [\"cols\"]\n\n    let pipe = Pipe()\n    task.standardOutput = pipe\n    task.launch()\n\n    let data = pipe.fileHandleForReading.readDataToEndOfFile()\n    task.waitUntilExit()\n\n    if let output = String(data: data, encoding: .utf8),\n       let columns = Int(output.trimmingCharacters(in: .whitespacesAndNewlines)) {\n        return columns\n    }\n\n    return nil\n}\n"
openssl.swift: "import Foundation\n#if canImport(Darwin)\nimport Darwin\n#else\nimport Glibc\n#endif\n\nfunc openssl_encrypt(_ inputFile: String, outputFile: String) {\n    let cleanInputFile = inputFile.trimmingCharacters(in: .whitespaces)\n    let cleanOutputFile = outputFile.trimmingCharacters(in: .whitespaces)\n    \n    let args = [\n        \"openssl\",\n        \"enc\",\n        \"-aes-256-cbc\",\n        \"-salt\",\n        \"-pbkdf2\",\n        \"-iter\",\n        \"1000000\",\n        \"-in\",\n        cleanInputFile,\n        \"-out\",\n        cleanOutputFile\n    ]\n    print(\"OpenSSL Args:\", args)\n    var cArgs: [UnsafeMutablePointer<CChar>?] = args.map { strdup($0) }\n    cArgs.append(nil)\n    \n    var pid: pid_t = 0\n    let status = posix_spawn(&pid, \"/usr/bin/openssl\", nil, nil, &cArgs, environ)\n    \n    // Free C strings\n    for arg in cArgs where arg != nil {\n        free(arg)\n    }\n    \n    if status == 0 {\n        // Wait for child process to finish\n        var waitStatus: Int32 = 0\n        waitpid(pid, &waitStatus, 0)\n        \n        let exitCode = (waitStatus >> 8) & 0xFF\n        if exitCode != 0 {\n            print(\"OpenSSL failed with exit code: \\(exitCode)\")\n        }\n    } else {\n        print(\"Failed to spawn process: \\(String(cString: strerror(status)))\")\n    }\n}\n\nfunc openssl_decrypt(_ inputFile: String, outputFile: String) {\n    let cleanInputFile = inputFile.trimmingCharacters(in: .whitespaces)\n    let cleanOutputFile = outputFile.trimmingCharacters(in: .whitespaces)\n    \n    let args = [\n        \"openssl\",\n        \"enc\",\n        \"-d\",\n        \"-aes-256-cbc\",\n        \"-salt\",\n        \"-pbkdf2\",\n        \"-iter\",\n        \"1000000\",\n        \"-in\",\n        cleanInputFile,\n        \"-out\",\n        cleanOutputFile\n    ]\n    print(\"OpenSSL Args:\", args)\n    var cArgs: [UnsafeMutablePointer<CChar>?] = args.map { strdup($0) }\n    cArgs.append(nil)\n    \n    var pid: pid_t = 0\n    let status = posix_spawn(&pid, \"/usr/bin/openssl\", nil, nil, &cArgs, environ)\n    \n    for arg in cArgs where arg != nil {\n        free(arg)\n    }\n    \n    if status == 0 {\n        var waitStatus: Int32 = 0\n        waitpid(pid, &waitStatus, 0)\n        \n        let exitCode = (waitStatus >> 8) & 0xFF\n        if exitCode != 0 {\n            print(\"OpenSSL failed with exit code: \\(exitCode)\")\n        }\n    } else {\n        print(\"Failed to spawn process: \\(String(cString: strerror(status)))\")\n    }\n}\n"
secureEnclave.swift: "//\n//  secureEnclave.swift\n//  SDist\n//\n//  Secure Enclave encryption implementation for macOS with Touch ID\n//  Uses hybrid encryption: SE-backed key wrapping + AES-256-GCM\n//\n\n#if os(macOS)\n\nimport Foundation\nimport CryptoKit\nimport LocalAuthentication\n\n// MARK: - Constants\n\nprivate let MAGIC_HEADER: [UInt8] = [0x53, 0x44, 0x49, 0x53, 0x54, 0x2E, 0x53, 0x45] // \"SDIST.SE\"\nprivate let FORMAT_VERSION: UInt16 = 2\nprivate let GCM_NONCE_SIZE = 12\nprivate let GCM_TAG_SIZE = 16\nprivate let INTEGRITY_HASH_SIZE = 32\n\n// MARK: - Errors\n\nenum SEEncryptionError: Error, CustomStringConvertible {\n    case fileReadError(String)\n    case fileWriteError(String)\n    case keyGenerationFailed(String)\n    case keyNotFound(String)\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidFileFormat(String)\n    case integrityCheckFailed\n    case authenticationFailed(String)\n    case unsupportedVersion(UInt16)\n    case biometryNotAvailable(String)\n\n    var description: String {\n        switch self {\n        case .fileReadError(let msg): return \"File read error: \\(msg)\"\n        case .fileWriteError(let msg): return \"File write error: \\(msg)\"\n        case .keyGenerationFailed(let msg): return \"Key generation failed: \\(msg)\"\n        case .keyNotFound(let msg): return \"SE key not found: \\(msg)\"\n        case .encryptionFailed(let msg): return \"Encryption failed: \\(msg)\"\n        case .decryptionFailed(let msg): return \"Decryption failed: \\(msg)\"\n        case .invalidFileFormat(let msg): return \"Invalid file format: \\(msg)\"\n        case .integrityCheckFailed: return \"Integrity check failed - file may be corrupted or tampered\"\n        case .authenticationFailed(let msg): return \"Authentication failed: \\(msg)\"\n        case .unsupportedVersion(let ver): return \"Unsupported file version: \\(ver)\"\n        case .biometryNotAvailable(let msg): return \"Biometry not available: \\(msg)\"\n        }\n    }\n}\n\n// MARK: - Metadata Structure\n\nprivate struct SEFileMetadata: Codable {\n    let version: Int\n    let seKeyID: String\n    let seKeyLabel: String\n    let algorithm: String\n    let keyEncryptionAlgorithm: String\n    let nonce: String // Base64-encoded\n    let timestamp: Int\n    let originalFilename: String?\n    let reserved: [String: String]\n    \n    init(seKeyID: String, seKeyLabel: String, nonce: Data, originalFilename: String? = nil) {\n        self.version = 1\n        self.seKeyID = seKeyID\n        self.seKeyLabel = seKeyLabel\n        self.algorithm = \"AES-256-GCM\"\n        self.keyEncryptionAlgorithm = \"ECIES-P256\"\n        self.nonce = nonce.base64EncodedString()\n        self.timestamp = Int(Date().timeIntervalSince1970)\n        self.originalFilename = originalFilename\n        self.reserved = [:]\n    }\n\n    init(version: Int, seKeyID: String, seKeyLabel: String, algorithm: String, keyEncryptionAlgorithm: String, nonce: String, timestamp: Int, originalFilename: String?, reserved: [String : String]) {\n        self.version = version\n        self.seKeyID = seKeyID\n        self.seKeyLabel = seKeyLabel\n        self.algorithm = algorithm\n        self.keyEncryptionAlgorithm = keyEncryptionAlgorithm\n        self.nonce = nonce\n        self.timestamp = timestamp\n        self.originalFilename = originalFilename\n        self.reserved = reserved\n    }\n}\n\nprivate func stripMetadata(_ metadata: SEFileMetadata) -> SEFileMetadata{\n    // removes all metadata from `SEFileMetadata`. SEFileMetadata is kept for backwards compatibility\n    return .init(version: 2, seKeyID: metadata.seKeyID, seKeyLabel: metadata.seKeyLabel, algorithm: metadata.algorithm, keyEncryptionAlgorithm: metadata.keyEncryptionAlgorithm, nonce: metadata.nonce, timestamp: 0, originalFilename: nil, reserved: metadata.reserved)\n}\n\n// MARK: - Biometry Helper\n\nprivate class BiometryHelper {\n    \n    /// Check if biometric authentication is available on this device\n    static func isBiometryAvailable() -> (available: Bool, biometryType: LABiometryType, error: Error?) {\n        let context = LAContext()\n        var error: NSError?\n        \n        let canEvaluate = context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error)\n        \n        return (canEvaluate, context.biometryType, error)\n    }\n    \n    /// Get a user-friendly description of the available biometry type\n    static func getBiometryDescription() -> String {\n        let context = LAContext()\n        switch context.biometryType {\n        case .none:\n            return \"No biometric authentication\"\n        case .touchID:\n            return \"Touch ID\"\n        case .faceID:\n            return \"Face ID\"\n        case .opticID:\n            return \"Optic ID\"\n        @unknown default:\n            return \"Unknown biometric type\"\n        }\n    }\n    \n    /// Perform biometric authentication with a custom reason\n    static func authenticate(reason: String, completion: @escaping (Bool, Error?) -> Void) {\n        let context = LAContext()\n        var error: NSError?\n        \n        // First check if biometry is available\n        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n            DispatchQueue.main.async {\n                completion(false, error ?? SEEncryptionError.biometryNotAvailable(\"Biometric authentication not available\"))\n            }\n            return\n        }\n        \n        // Perform the authentication\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authError in\n            DispatchQueue.main.async {\n                completion(success, authError)\n            }\n        }\n    }\n}\n\n// MARK: - Secure Enclave Key Management\n\nprivate class SEKeyManager {\n\n    /// Get or create a Secure Enclave key with Touch ID protection\n    static func getOrCreateKey(label: String, requireBiometry: Bool = true) throws -> SecureEnclave.P256.KeyAgreement.PrivateKey {\n        // Try to retrieve existing key\n        if let existingKey = try? retrieveKey(label: label) {\n            print(\"Using existing Secure Enclave key: \\(label)\")\n            return existingKey\n        }\n\n        // Create new key\n        print(\"Creating new Secure Enclave key: \\(label)\")\n        return try createKey(label: label, requireBiometry: requireBiometry)\n    }\n\n    /// Create a new Secure Enclave key with Touch ID protection\n    static func createKey(label: String, requireBiometry: Bool = true) throws -> SecureEnclave.P256.KeyAgreement.PrivateKey {\n        do {\n            // Check if biometry is available if required\n            if requireBiometry {\n                let biometryCheck = BiometryHelper.isBiometryAvailable()\n                guard biometryCheck.available else {\n                    throw SEEncryptionError.biometryNotAvailable(\n                        \"Touch ID is not available. Please ensure biometric authentication is enabled in System Settings.\"\n                    )\n                }\n                print(\"âœ“ \\(BiometryHelper.getBiometryDescription()) is available\")\n            }\n            \n            // Create access control for the key with Touch ID requirement\n            let flags: SecAccessControlCreateFlags\n            if requireBiometry {\n                // Use biometryCurrentSet to strictly require Touch ID\n                // This ties the key to the current set of enrolled fingerprints\n                flags = [.privateKeyUsage, .biometryCurrentSet]\n                print(\"Creating key with Touch ID requirement\")\n            } else {\n                // Fallback: use userPresence which allows both biometry and device passcode\n                flags = [.privateKeyUsage, .userPresence]\n                print(\"Creating key with user presence requirement (Touch ID or passcode)\")\n            }\n            \n            var error: Unmanaged<CFError>?\n            guard let accessControl = SecAccessControlCreateWithFlags(\n                kCFAllocatorDefault,\n                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                flags,\n                &error\n            ) else {\n                if let cfError = error?.takeRetainedValue() {\n                    throw SEEncryptionError.keyGenerationFailed(\"Failed to create access control: \\(cfError)\")\n                }\n                throw SEEncryptionError.keyGenerationFailed(\"Failed to create access control\")\n            }\n\n            // Create authentication context with a clear prompt\n            let authContext = LAContext()\n            authContext.localizedReason = \"Authenticate to create encryption key\"\n            // Allow reuse of authentication for 60 seconds to avoid multiple prompts\n            authContext.touchIDAuthenticationAllowableReuseDuration = 60\n\n            // Generate key in Secure Enclave\n            let tag = \"com.sdist.sekey.\\(label)\".data(using: .utf8)!\n\n            let key = try SecureEnclave.P256.KeyAgreement.PrivateKey(\n                compactRepresentable: false,\n                accessControl: accessControl,\n                authenticationContext: authContext\n            )\n\n            // Store key reference in keychain with proper attributes\n            try storeKeyReference(key: key, label: label, tag: tag)\n\n            print(\"âœ“ Secure Enclave key created successfully\")\n            return key\n        } catch let error as SEEncryptionError {\n            throw error\n        } catch {\n            throw SEEncryptionError.keyGenerationFailed(error.localizedDescription)\n        }\n    }\n\n    /// Retrieve an existing Secure Enclave key and authenticate with Touch ID\n    static func retrieveKey(label: String) throws -> SecureEnclave.P256.KeyAgreement.PrivateKey {\n        // Query the stored data representation\n        let dataQuery: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrAccount as String: label,\n            kSecAttrService as String: \"SDist-SE-KeyData\",\n            kSecReturnData as String: true\n        ]\n\n        var dataItem: CFTypeRef?\n        let dataStatus = SecItemCopyMatching(dataQuery as CFDictionary, &dataItem)\n\n        guard dataStatus == errSecSuccess, let keyData = dataItem as? Data else {\n            throw SEEncryptionError.keyNotFound(\"Key data not found for label '\\(label)' (status: \\(dataStatus))\")\n        }\n\n        do {\n            // Reconstruct the key - this will trigger Touch ID prompt if required by the key's ACL\n            return try SecureEnclave.P256.KeyAgreement.PrivateKey(dataRepresentation: keyData)\n        } catch {\n            throw SEEncryptionError.keyNotFound(\"Failed to reconstruct key (may require Touch ID): \\(error.localizedDescription)\")\n        }\n    }\n\n    /// Store key reference in keychain\n    private static func storeKeyReference(key: SecureEnclave.P256.KeyAgreement.PrivateKey, label: String, tag: Data) throws {\n        // Store the key's data representation for later retrieval\n        let keyData = key.dataRepresentation\n\n        // Store as generic password for easy retrieval\n        let addQuery: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrAccount as String: label,\n            kSecAttrService as String: \"SDist-SE-KeyData\",\n            kSecValueData as String: keyData,\n            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n        ]\n\n        let status = SecItemAdd(addQuery as CFDictionary, nil)\n        if status != errSecSuccess && status != errSecDuplicateItem {\n            throw SEEncryptionError.keyGenerationFailed(\"Failed to store key data: \\(status)\")\n        }\n\n        print(\"Key stored successfully with label: \\(label)\")\n    }\n}\n\n// MARK: - Binary Writer Helper\n\nprivate class BinaryWriter {\n    private var data = Data()\n\n    func write(_ bytes: [UInt8]) {\n        data.append(contentsOf: bytes)\n    }\n\n    func writeUInt16BigEndian(_ value: UInt16) {\n        data.append(contentsOf: [\n            UInt8((value >> 8) & 0xFF),\n            UInt8(value & 0xFF)\n        ])\n    }\n\n    func writeUInt32BigEndian(_ value: UInt32) {\n        data.append(contentsOf: [\n            UInt8((value >> 24) & 0xFF),\n            UInt8((value >> 16) & 0xFF),\n            UInt8((value >> 8) & 0xFF),\n            UInt8(value & 0xFF)\n        ])\n    }\n\n    func writeData(_ data: Data) {\n        self.data.append(data)\n    }\n\n    func getData() -> Data {\n        return data\n    }\n}\n\n// MARK: - Binary Reader Helper\n\nprivate class BinaryReader {\n    private let data: Data\n    private var offset: Int = 0\n\n    init(data: Data) {\n        self.data = data\n    }\n\n    func readBytes(_ count: Int) throws -> [UInt8] {\n        guard offset + count <= data.count else {\n            throw SEEncryptionError.invalidFileFormat(\"Unexpected end of file\")\n        }\n        let bytes = Array(data[offset..<(offset + count)])\n        offset += count\n        return bytes\n    }\n\n    func readUInt16BigEndian() throws -> UInt16 {\n        let bytes = try readBytes(2)\n        return (UInt16(bytes[0]) << 8) | UInt16(bytes[1])\n    }\n\n    func readUInt32BigEndian() throws -> UInt32 {\n        let bytes = try readBytes(4)\n        return (UInt32(bytes[0]) << 24) | (UInt32(bytes[1]) << 16) |\n               (UInt32(bytes[2]) << 8) | UInt32(bytes[3])\n    }\n\n    func readData(_ count: Int) throws -> Data {\n        guard offset + count <= data.count else {\n            throw SEEncryptionError.invalidFileFormat(\"Unexpected end of file\")\n        }\n        let result = data.subdata(in: offset..<(offset + count))\n        offset += count\n        return result\n    }\n\n    func readRemainingData() -> Data {\n        return data.subdata(in: offset..<data.count)\n    }\n\n    func getCurrentOffset() -> Int {\n        return offset\n    }\n\n    func getDataUpToCurrentOffset() -> Data {\n        return data.subdata(in: 0..<offset)\n    }\n}\n\n// MARK: - Public Encryption Function\n\nfunc se_encrypt(_ inputFile: String, outputFile: String, keyLabel: String? = nil, requireBiometry: Bool = true) {\n    do {\n        // Clean paths\n        let cleanInputFile = inputFile.trimmingCharacters(in: .whitespaces)\n        let cleanOutputFile = outputFile.trimmingCharacters(in: .whitespaces)\n\n        print(\"Starting Secure Enclave encryption with Touch ID...\")\n        print(\"Input: \\(cleanInputFile)\")\n        print(\"Output: \\(cleanOutputFile)\")\n        \n        // Check biometry availability\n        let biometryCheck = BiometryHelper.isBiometryAvailable()\n        if requireBiometry && !biometryCheck.available {\n            print(\"âš ï¸  Warning: Touch ID not available, falling back to user presence (Touch ID or passcode)\")\n            print(\"   Enable Touch ID in System Settings for enhanced security\")\n        }\n\n        // Read input file\n        guard let fileData = FileManager.default.contents(atPath: cleanInputFile) else {\n            throw SEEncryptionError.fileReadError(\"Cannot read file: \\(cleanInputFile)\")\n        }\n\n        let originalFilename = URL(fileURLWithPath: cleanInputFile).lastPathComponent\n\n        // Generate or retrieve SE key with Touch ID protection\n        let label = keyLabel ?? \"SDist-SE-Key-Default\"\n        print(\"\\nAuthenticating with \\(BiometryHelper.getBiometryDescription())...\")\n        \n        let sePrivateKey = try SEKeyManager.getOrCreateKey(label: label, requireBiometry: requireBiometry)\n        let sePublicKey = sePrivateKey.publicKey\n\n        // Generate random AES-256 key\n        let aesKey = SymmetricKey(size: .bits256)\n\n        // Generate random nonce for GCM\n        var nonceBytes = [UInt8](repeating: 0, count: GCM_NONCE_SIZE)\n        guard SecRandomCopyBytes(kSecRandomDefault, GCM_NONCE_SIZE, &nonceBytes) == errSecSuccess else {\n            throw SEEncryptionError.encryptionFailed(\"Failed to generate random nonce\")\n        }\n        let nonce = try AES.GCM.Nonce(data: Data(nonceBytes))\n\n        // Encrypt file data with AES-GCM\n        print(\"Encrypting file content with AES-256-GCM...\")\n        let sealedBox = try AES.GCM.seal(fileData, using: aesKey, nonce: nonce)\n\n        guard let encryptedContent = sealedBox.combined else {\n            throw SEEncryptionError.encryptionFailed(\"Failed to get encrypted content\")\n        }\n\n        // Extract raw AES key data\n        let aesKeyData = aesKey.withUnsafeBytes { Data($0) }\n\n        // Encrypt AES key with SE public key using key agreement (ECIES-like)\n        let ephemeralKey = P256.KeyAgreement.PrivateKey()\n        let sharedSecret = try ephemeralKey.sharedSecretFromKeyAgreement(with: sePublicKey)\n\n        // Derive encryption key from shared secret\n        let wrapKey = sharedSecret.hkdfDerivedSymmetricKey(\n            using: SHA256.self,\n            salt: Data(),\n            sharedInfo: \"SDist-SE-Key-Wrap\".data(using: .utf8)!,\n            outputByteCount: 32\n        )\n\n        // Encrypt AES key with derived wrap key\n        let wrappedKeyBox = try AES.GCM.seal(aesKeyData, using: wrapKey)\n        guard var encryptedAESKey = wrappedKeyBox.combined else {\n            throw SEEncryptionError.encryptionFailed(\"Failed to wrap AES key\")\n        }\n\n        // Prepend ephemeral public key to encrypted key (needed for decryption)\n        let ephemeralPublicKeyData = ephemeralKey.publicKey.x963Representation\n        encryptedAESKey = ephemeralPublicKeyData + encryptedAESKey\n\n        // Zero out sensitive key material\n        var zeroedKey = aesKeyData\n        _ = zeroedKey.withUnsafeMutableBytes { ptr in\n            memset(ptr.baseAddress, 0, ptr.count)\n        }\n\n        // Build metadata\n        let keyID = \"sdist.se.\\(label).\\(UUID().uuidString)\"\n        let metadata = stripMetadata(SEFileMetadata(\n            seKeyID: keyID,\n            seKeyLabel: label,\n            nonce: Data(nonceBytes),\n            originalFilename: originalFilename\n        ))\n\n        let encoder = JSONEncoder()\n        let metadataJSON = try encoder.encode(metadata)\n\n        // Build binary file\n        let writer = BinaryWriter()\n\n        // Write magic header\n        writer.write(MAGIC_HEADER)\n\n        // Write version\n        writer.writeUInt16BigEndian(FORMAT_VERSION)\n\n        // Write metadata length and data\n        writer.writeUInt32BigEndian(UInt32(metadataJSON.count))\n        writer.writeData(metadataJSON)\n\n        // Write encrypted AES key length and data\n        writer.writeUInt32BigEndian(UInt32(encryptedAESKey.count))\n        writer.writeData(encryptedAESKey)\n\n        // Calculate and write integrity marker (SHA-256 of everything so far)\n        let integrityData = writer.getData()\n        let integrityHash = SHA256.hash(data: integrityData)\n        writer.writeData(Data(integrityHash))\n\n        // Write encrypted content (ciphertext + tag)\n        writer.writeData(encryptedContent)\n\n        // Write to output file\n        let finalData = writer.getData()\n        do {\n            try finalData.write(to: URL(fileURLWithPath: cleanOutputFile))\n            print(\"\\nâœ“ Encryption successful!\")\n            print(\"  Output file size: \\(finalData.count) bytes\")\n            print(\"  Original size: \\(fileData.count) bytes\")\n            print(\"  Overhead: \\(finalData.count - fileData.count) bytes\")\n            print(\"  SE Key: \\(label)\")\n            print(\"  Protection: Secure Enclave with Touch ID authentication\")\n        } catch {\n            throw SEEncryptionError.fileWriteError(error.localizedDescription)\n        }\n\n    } catch let error as SEEncryptionError {\n        print(\"âŒ SE Encryption Error: \\(error.description)\")\n    } catch {\n        print(\"âŒ Unexpected error: \\(error.localizedDescription)\")\n    }\n}\n\n// MARK: - Public Decryption Function\n\nfunc se_decrypt(_ inputFile: String, outputFile: String) {\n    do {\n        // Clean paths\n        let cleanInputFile = inputFile.trimmingCharacters(in: .whitespaces)\n        let cleanOutputFile = outputFile.trimmingCharacters(in: .whitespaces)\n\n        print(\"Starting Secure Enclave decryption with Touch ID...\")\n        print(\"Input: \\(cleanInputFile)\")\n        print(\"Output: \\(cleanOutputFile)\")\n\n        // Read encrypted file\n        guard let fileData = FileManager.default.contents(atPath: cleanInputFile) else {\n            throw SEEncryptionError.fileReadError(\"Cannot read file: \\(cleanInputFile)\")\n        }\n\n        let reader = BinaryReader(data: fileData)\n\n        // Read and verify magic header\n        let magic = try reader.readBytes(8)\n        guard magic == MAGIC_HEADER else {\n            throw SEEncryptionError.invalidFileFormat(\"Invalid magic header - not a Secure Enclave encrypted file\")\n        }\n\n        // Read and check version\n        let version = try reader.readUInt16BigEndian()\n        guard version <= FORMAT_VERSION else {\n            throw SEEncryptionError.unsupportedVersion(version)\n        }\n\n        // Read metadata\n        let metadataLength = try reader.readUInt32BigEndian()\n        let metadataJSON = try reader.readData(Int(metadataLength))\n\n        let decoder = JSONDecoder()\n        let metadata = try decoder.decode(SEFileMetadata.self, from: metadataJSON)\n\n        print(\"\\nFile metadata:\")\n        if metadata.timestamp > 0 {\n            print(\"  Encrypted: \\(Date(timeIntervalSince1970: TimeInterval(metadata.timestamp)))\")\n        }\n        if let filename = metadata.originalFilename {\n            print(\"  Original filename: \\(filename)\")\n        }\n        print(\"  SE Key: \\(metadata.seKeyLabel)\")\n\n        // Read encrypted AES key\n        let encryptedKeyLength = try reader.readUInt32BigEndian()\n        let encryptedAESKeyFull = try reader.readData(Int(encryptedKeyLength))\n\n        // Verify integrity marker\n        let integrityMarker = try reader.readData(INTEGRITY_HASH_SIZE)\n        let dataToVerify = reader.getDataUpToCurrentOffset().subdata(in: 0..<(reader.getCurrentOffset() - INTEGRITY_HASH_SIZE))\n        let calculatedHash = SHA256.hash(data: dataToVerify)\n\n        guard Data(calculatedHash) == integrityMarker else {\n            throw SEEncryptionError.integrityCheckFailed\n        }\n        print(\"âœ“ Integrity check passed\")\n\n        // Read encrypted content (rest of file)\n        let encryptedContent = reader.readRemainingData()\n\n        // Retrieve SE private key - this will trigger Touch ID prompt\n        print(\"\\nAuthenticating with \\(BiometryHelper.getBiometryDescription())...\")\n        print(\"(You will be prompted for authentication)\")\n\n        let sePrivateKey = try SEKeyManager.getOrCreateKey(label: metadata.seKeyLabel)\n\n        // Split ephemeral public key and encrypted AES key\n        guard encryptedAESKeyFull.count > 65 else {\n            throw SEEncryptionError.decryptionFailed(\"Invalid encrypted key format: got \\(encryptedAESKeyFull.count) bytes, expected > 65\")\n        }\n\n        let ephemeralPublicKeyData = encryptedAESKeyFull.prefix(65) // 65 bytes for P256 public key\n        let wrappedKey = encryptedAESKeyFull.suffix(from: 65)\n\n        // Reconstruct ephemeral public key and perform key agreement\n        let ephemeralPublicKey = try P256.KeyAgreement.PublicKey(x963Representation: ephemeralPublicKeyData)\n        let sharedSecret = try sePrivateKey.sharedSecretFromKeyAgreement(with: ephemeralPublicKey)\n\n        // Derive the same wrap key\n        let wrapKey = sharedSecret.hkdfDerivedSymmetricKey(\n            using: SHA256.self,\n            salt: Data(),\n            sharedInfo: \"SDist-SE-Key-Wrap\".data(using: .utf8)!,\n            outputByteCount: 32\n        )\n\n        // Decrypt AES key\n        let sealedBox = try AES.GCM.SealedBox(combined: wrappedKey)\n        let aesKeyData = try AES.GCM.open(sealedBox, using: wrapKey)\n        let aesKey = SymmetricKey(data: aesKeyData)\n\n        // Decrypt file content\n        print(\"Decrypting file content...\")\n        let contentSealedBox = try AES.GCM.SealedBox(combined: encryptedContent)\n        let decryptedData = try AES.GCM.open(contentSealedBox, using: aesKey)\n\n        // Write decrypted file\n        do {\n            try decryptedData.write(to: URL(fileURLWithPath: cleanOutputFile))\n            print(\"\\nâœ“ Decryption successful!\")\n            print(\"  Output file size: \\(decryptedData.count) bytes\")\n            print(\"  File restored successfully\")\n        } catch {\n            throw SEEncryptionError.fileWriteError(error.localizedDescription)\n        }\n\n        // Zero out sensitive data\n        var zeroedKey = aesKeyData\n        _ = zeroedKey.withUnsafeMutableBytes { ptr in\n            memset(ptr.baseAddress, 0, ptr.count)\n        }\n\n    } catch let error as SEEncryptionError {\n        print(\"âŒ SE Decryption Error: \\(error.description)\")\n    } catch {\n        print(\"âŒ Unexpected error: \\(error.localizedDescription)\")\n    }\n}\n\n// MARK: - Key Management Functions\n\nfunc se_cleanup_old_keys() {\n    print(\"Cleaning up old SE key storage...\")\n\n    // Delete old generic password entries\n    let deleteQuery1: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"SDist-SE-Keys\"\n    ]\n    SecItemDelete(deleteQuery1 as CFDictionary)\n\n    // Also clean up the new storage if needed\n    let deleteQuery2: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"SDist-SE-KeyData\"\n    ]\n    SecItemDelete(deleteQuery2 as CFDictionary)\n\n    print(\"Cleanup complete. Please encrypt your file again with a fresh key.\")\n}\n\nfunc se_list_keys() {\n    print(\"Listing Secure Enclave keys in keychain...\")\n    print(\"\\nAvailable biometry: \\(BiometryHelper.getBiometryDescription())\")\n\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: \"SDist-SE-KeyData\",\n        kSecMatchLimit as String: kSecMatchLimitAll,\n        kSecReturnAttributes as String: true\n    ]\n\n    var items: CFTypeRef?\n    let status = SecItemCopyMatching(query as CFDictionary, &items)\n\n    guard status == errSecSuccess, let keyItems = items as? [[String: Any]] else {\n        print(\"No SE keys found in keychain\")\n        return\n    }\n\n    print(\"Found \\(keyItems.count) key(s):\")\n    for (index, item) in keyItems.enumerated() {\n        let label = item[kSecAttrAccount as String] as? String ?? \"Unknown\"\n        print(\"  \\(index + 1). \\(label)\")\n    }\n    print(\"\\nðŸ’¡ These keys are protected by Touch ID authentication\")\n}\n\n// MARK: - Biometry Information Function\n\nfunc se_check_biometry() {\n    print(\"Checking biometric authentication capabilities...\\n\")\n    \n    let biometryCheck = BiometryHelper.isBiometryAvailable()\n    \n    print(\"Biometry Type: \\(BiometryHelper.getBiometryDescription())\")\n    print(\"Available: \\(biometryCheck.available ? \"âœ“ Yes\" : \"âœ— No\")\")\n    \n    if let error = biometryCheck.error {\n        print(\"Status: \\(error.localizedDescription)\")\n        \n        if let laError = error as? LAError {\n            switch laError.code {\n            case .biometryNotAvailable:\n                print(\"\\nðŸ’¡ Touch ID is not available on this Mac\")\n            case .biometryNotEnrolled:\n                print(\"\\nðŸ’¡ Touch ID is available but not set up\")\n                print(\"   Go to System Settings > Touch ID & Password to enroll your fingerprint\")\n            case .biometryLockout:\n                print(\"\\nâš ï¸  Touch ID is locked due to too many failed attempts\")\n                print(\"   Unlock your Mac to reset Touch ID\")\n            case .passcodeNotSet:\n                print(\"\\nðŸ’¡ No password is set on this Mac\")\n                print(\"   Set a password in System Settings to enable Touch ID\")\n            default:\n                print(\"\\nâš ï¸  Error code: \\(laError.code.rawValue)\")\n            }\n        }\n    } else if biometryCheck.available {\n        print(\"Status: Ready for use\")\n        print(\"\\nâœ“ Your files can be protected with Touch ID authentication\")\n    }\n    \n    print(\"\\nNote: Secure Enclave encryption works on Macs with:\")\n    print(\"  â€¢ Apple Silicon (M1, M2, M3, M4 chips)\")\n    print(\"  â€¢ T2 Security Chip (some Intel Macs)\")\n}\n\n#endif // os(macOS)\n"
commands.swift: "//\n//  commands.swift\n//  SDist\n//\n//  Created by Sal Faris on 27/02/2024.\n//\n\nimport Foundation\n\nenum Errors: Error {\n    case noMoreParams\n    case fileNotFound(String)\n}\n\nfileprivate let special = \"XS@#$%\"\nfileprivate var paramIdsCalls: [String: Int] = [:]\ntypealias dynamicParams = [String: String]\n\nextension dynamicParams {\n    private static var orderedKeys: [String: [String]] = [:]\n    \n    func getKey(_ string: String, alternative_method: () -> (String)) -> String {\n        let specialId = Array(self.keys).sorted().joined()\n        \n        do {\n            if self.keys.contains(string) {\n                return self[string]!\n            } else {\n                // Get the ordered keys for this params instance\n                guard let orderedKeys = dynamicParams.orderedKeys[specialId] else {\n                    return alternative_method()\n                }\n                \n                // Check if using indexed special keys (format: \"0\", \"1\", \"2\", etc.)\n                let indexedKeys = orderedKeys.enumerated().map { String($0.offset) }\n                if let firstIndexKey = indexedKeys.first, self[firstIndexKey] == special {\n                    if let pos = paramIdsCalls[specialId] {\n                        paramIdsCalls[specialId] = pos + 1\n                        if orderedKeys.count <= (pos + 1) {\n                            throw Errors.noMoreParams\n                        }\n                        return orderedKeys[pos + 1]\n                    } else {\n                        paramIdsCalls[specialId] = 0\n                        return orderedKeys[0]\n                    }\n                }\n            }\n        } catch {\n            if arguments.contains(.errorOnNoParamsError) {\n                print(\"Error: \\(error). Interactive mode is disabled.\")\n                exit(EXIT_FAILURE)\n            } else {\n                print(\"Error: \\(error). Falling back to interactive mode.\")\n            }\n        }\n        \n        return alternative_method()\n    }\n    \n    init(fromArray: [String]) {\n        self.init()\n        let specialId = fromArray.enumerated().map { String($0.offset) }.sorted().joined()\n        dynamicParams.orderedKeys[specialId] = fromArray // Store the original order!\n        // Use indices as keys instead of the actual values\n        for (index, _) in fromArray.enumerated() {\n            self[String(index)] = special\n        }\n    }\n}\n\nlet tempDir = URL(filePath: NSTemporaryDirectory())\nlet fm = FileManager.default\n\nfunc askUser(question: String) -> String{\n    print(question)\n    return readLine()!\n}\n\nfunc askUserWrapper(question: String) -> () -> String{\n    func wrapper() -> String{\n        print(question)\n        return readLine()!\n    }\n    \n    return wrapper\n}\n\nfunc get_location(_ params: dynamicParams) throws{\n    let key = params.getKey(\"key\", alternative_method: askUserWrapper(question: \"Enter Asset Key:\"))\n    let response = GET(url: .init(format: Endpoints.location, key, PASSWORD))\n    if try _check_response(response){\n        print(\"URL:\", response!)\n    }\n}\n\nfunc download_asset(_ params: dynamicParams) throws {\n    let key = params.getKey(\"key\", alternative_method: askUserWrapper(question: \"Asset Key:\"))\n    let saveName = params.getKey(\"saveName\", alternative_method: askUserWrapper(question: \"What would you like to save the file as?:\"))\n    let response = GET(url: .init(format: Endpoints.location, key, PASSWORD))\n    if try !_check_response(response){\n        return\n    }\n    \n    \n    print(\"Downloading asset...\")\n    print(\"Downloading from:\", response!)\n    \n    downloadFile(url: response!, saveName: saveName)\n    let finalDestination = URL(filePath: FileManager.default.currentDirectoryPath).appending(path: saveName).path(percentEncoded: false)\n    print(\"Asset downloaded, file: \\(finalDestination)\")\n    \n    if saveName.contains(\".enc\"){\n        print(\".enc file detected, would you like to decrypt the file\")\n        let decrypt_file_user = params.getKey(\"decryptFile\", alternative_method: askUserWrapper(question: \"Would you like to decrypt this file (y/n):\"))\n        if decrypt_file_user.lowercased() == \"y\"{\n            print(\"Decryption is done via openssl, there is no support for command line mode.\")\n            decrypt_file(finalDestination, file: finalDestination.replacingOccurrences(of: \".enc\", with: \"\"))\n        }\n    }\n}\n\nfunc encrypt_asset(_ params: dynamicParams) throws{\n    let fp = params.getKey(\"path\", alternative_method: askUserWrapper(question: \"Filepath:\")).replacingOccurrences(of: \"\\\\ \", with: \" \")\n    var dst = params.getKey(\"dest\", alternative_method: askUserWrapper(question: \"Destination:\"))\n    if !dst.contains(\".enc\"){\n        print(\"Warning, per SDist encryption spec, the file will be saved with a .enc extension.\")\n        dst.append(\".enc\")\n    }\n    openssl_encrypt(fp, outputFile: dst)\n}\n\nfunc local_decrypt(_ params: dynamicParams) throws {\n    let fp = params.getKey(\"path\", alternative_method: askUserWrapper(question: \"Filepath:\")).replacingOccurrences(of: \"\\\\ \", with: \" \")\n    let dst = params.getKey(\"dest\", alternative_method: askUserWrapper(question: \"Destination:\"))\n    openssl_decrypt(fp, outputFile: dst)\n}\n\nfunc list_all(_ params: dynamicParams) throws{\n    let response = GET(url: .init(format: Endpoints.allLocation, PASSWORD))\n    if try !_check_response(response){\n        return\n    }\n    \n    print(\"Assets:\")\n    \n    if let jsonData = response!.data(using: .utf8) {\n        if let jsonArray = try JSONSerialization.jsonObject(with: jsonData, options: []) as? [String] {\n            for string in jsonArray{\n                print(\"*\", string)\n            }\n            \n        } else {\n            print(\"Failed to convert JSON string to array\")\n        }\n    } else {\n        print(\"Invalid JSON string\")\n    }\n    \n}\n\nfunc update_locations(_ params: dynamicParams) throws{\n    let key = params.getKey(\"key\", alternative_method: askUserWrapper(question: \"Asset Key:\"))\n    let url = params.getKey(\"url\", alternative_method: askUserWrapper(question: \"URL of the asset:\")).data(using: .utf8)!.base64EncodedString()\n    let response = GET(url: .init(format: Endpoints.setLocation, key, url, PASSWORD))\n    \n    print(\"Updating asset...\")\n    print(\"Server Response:\")\n    print(response ?? \"No response\")\n    if try !_check_response(response){\n        return\n    }\n}\n\nfunc remove_location(_ params: dynamicParams) throws {\n    let key = params.getKey(\"key\", alternative_method: askUserWrapper(question: \"Asset Key:\"))\n    let response = GET(url: .init(format: Endpoints.removeLocation, key, PASSWORD))\n    if try _check_response(response){\n        print(\"Server Response:\", response ?? \"cURL didn't return a response\")\n        print(\"Asset should be deleted.\")\n    }else{\n        print(\"Something went wrong. Server Response:\")\n        print(response ?? \"cURL didn't return a response\")\n    }\n}\n\nfunc save_password(_ params: dynamicParams) throws{\n    let password = params.getKey(\"password\", alternative_method: askUserWrapper(question: \"Password:\"))\n    let data = password.data(using: .utf8)!\n    try data.write(to: PW_location)\n}\n\nfunc help(_ params: dynamicParams){\n    let cmds = COMMANDS.sorted(by: {\n        let l1 = $0.key.count + ($0.value[\"description\"] as! String).count\n        let l2 = $1.key.count + ($1.value[\"description\"] as! String).count\n        \n        return l1 < l2\n    })\n\n    print(\"Commands:\")\n    for command in cmds {\n        print(\"\\t\\(command.key): \\(command.value[\"description\"]!)\")\n    }\n}\n\nfunc clearScreen(_ params: dynamicParams){\n    let clearScreen = Process()\n    clearScreen.launchPath = \"/usr/bin/clear\"\n    clearScreen.arguments = []\n    clearScreen.launch()\n    clearScreen.waitUntilExit()\n}\n\nfunc listDirectory(_ params: dynamicParams) {\n    let proc = Process()\n    proc.executableURL = URL(fileURLWithPath: \"/bin/ls\")\n    proc.arguments = [\"-lh\"]\n    try? proc.run()\n    proc.waitUntilExit()\n}\n\n#if os(macOS)\nfunc encrypt_asset_se(_ params: dynamicParams) throws {\n    let fp = params.getKey(\"path\", alternative_method: askUserWrapper(question: \"Filepath:\")).replacingOccurrences(of: \"\\\\ \", with: \" \")\n    var dst = params.getKey(\"dest\", alternative_method: askUserWrapper(question: \"Destination:\"))\n    if !dst.contains(\".enc.se\") {\n        print(\"Warning: per SDist SE encryption spec, the file will be saved with a .enc.se extension.\")\n        dst.append(\".enc.se\")\n    }\n    let keyLabel = params.getKey(\"keyLabel\", alternative_method: askUserWrapper(question: \"SE Key Label (optional, press enter or ? for default):\"))\n    \n    let finalKeyLabel: String?\n    switch keyLabel {\n    case \"\":\n        finalKeyLabel = nil\n    case \"?\":\n        finalKeyLabel = nil\n    default:\n        finalKeyLabel = keyLabel\n    }\n\n    se_encrypt(fp, outputFile: dst, keyLabel: finalKeyLabel)\n}\n\nfunc decrypt_asset_se(_ params: dynamicParams) throws {\n    let fp = params.getKey(\"path\", alternative_method: askUserWrapper(question: \"Filepath:\")).replacingOccurrences(of: \"\\\\ \", with: \" \")\n    let dst = params.getKey(\"dest\", alternative_method: askUserWrapper(question: \"Destination:\"))\n    se_decrypt(fp, outputFile: dst)\n}\n\nfunc list_se_keys(_ params: dynamicParams) throws {\n    se_list_keys()\n}\n\nfunc cleanup_se_keys(_ params: dynamicParams) throws {\n    se_cleanup_old_keys()\n}\n\nfunc install_app(_ params: dynamicParams) throws{\n    let key = params.getKey(\"key\", alternative_method: askUserWrapper(question: \"Enter Asset Key:\"))\n    let response = GET(url: .init(format: Endpoints.location, key, PASSWORD))\n    if try !_check_response(response){\n        return\n    }\n    \n    print(\"Downloading App Zip file\")\n    print(\"Downloading from: \\(response!)\")\n    let tempFile = tempDir.appending(path: \"saveapp.zip\")\n    downloadFile(url: response!, saveName: tempFile.path(percentEncoded: false))\n    print(\"App zip file downloaded to:\", tempFile.path(percentEncoded: false))\n    let random_num = (0...900000).randomElement()!\n    let random_directory = tempDir.appending(path: \"app_\" + random_num.description)\n    let current_directory = FileManager.default.currentDirectoryPath\n    try FileManager.default.createDirectory(at: random_directory, withIntermediateDirectories: false)\n    FileManager.default.changeCurrentDirectoryPath(random_directory.path(percentEncoded: false))\n    print(\"Extracting app from zip file\")\n    unzip(tempFilePath: tempFile.path(percentEncoded: false))\n    \n    let cmds = [\n        [\"xattr\", \"-d\", \"com.apple.quarantine\"],\n        [\"chmod\", \"+x\"],\n        [\"xattr\", \"-cr\"]\n    ]\n    \n    rm(random_directory.appending(path: \"__MACOSX\").path(percentEncoded: false))\n    \n    if let app_real_name = try FileManager.default.contentsOfDirectory(atPath: random_directory.path(percentEncoded: false)).first{\n        let app_name = random_directory.appending(path: app_real_name)\n        let app_file_destination = URL(filePath: current_directory).appending(path: app_real_name)\n        print(\"Setting Permissions\")\n        for var cmd in cmds {\n            let process = Process()\n            process.executableURL = .init(filePath: \"/usr/bin/env\")\n            cmd.append(app_name.path(percentEncoded: false))\n            process.arguments = cmd\n            do{\n                try process.run()\n                process.waitUntilExit()\n            } catch {\n                print(\"Failed: \\(cmd), error: \\(error)\")\n            }\n        }\n        \n        \n        print(\"Cleaning up....\")\n        FileManager.default.changeCurrentDirectoryPath(current_directory)\n        mv(app_name.path(percentEncoded: false), destination: app_file_destination.path(percentEncoded: false))\n        \n        print(\"App available at: \\(app_file_destination.path(percentEncoded: false))\")\n        rm(tempFile.path(percentEncoded: false))\n        rm(tempDir.path(percentEncoded: false))\n        print(\"Install Completed\")\n    }else{\n        print(\"The downloaded asset does not support the install command. Please use 'download' instead.\")\n        rm(tempFile.path(percentEncoded: false))\n        rm(tempDir.path(percentEncoded: false))\n    }\n    \n   \n}\n\nfunc install_app_from_encrypted_zip(_ params: dynamicParams) throws {\n    let encryptedPath = params.getKey(\"path\", alternative_method: askUserWrapper(question: \"Encrypted Path\"))\n    var appName = params.getKey(\"appName\", alternative_method: askUserWrapper(question: \"App Name\"))\n    if !appName.hasSuffix(\".app\"){\n        appName += \".app\"\n    }\n    let dest = fm.currentDirectoryPath.appending(\"/\" + appName + \".zip\")\n    decrypt_file(encryptedPath, file: dest)\n    \n    let random_num = (0...900000).randomElement()!\n    let random_directory = tempDir.appending(path: \"app_\" + random_num.description)\n    let cwd = fm.currentDirectoryPath\n    try fm.createDirectory(at: random_directory, withIntermediateDirectories: true)\n    fm.changeCurrentDirectoryPath(random_directory.path(percentEncoded: false))\n    print(\"Temporary Directory: \\(random_directory.path(percentEncoded: false))\")\n    unzip(tempFilePath: dest)\n    if fm.fileExists(atPath: \"./__MACOSX\"){\n        try fm.removeItem(atPath: \"./__MACOSX\")\n    }\n    let files = try fm.contentsOfDirectory(atPath: \".\")\n    print(\"Available Files: \\(files)\")\n    let tempApp = fm.currentDirectoryPath.appending(\"/\" + (try fm.contentsOfDirectory(atPath: \".\").first!))\n    try fixApplication(appURL: .init(filePath: tempApp))\n    try fm.copyItem(at: URL(fileURLWithPath: tempApp), to: URL(fileURLWithPath: cwd).appendingPathComponent(appName))\n    fm.changeCurrentDirectoryPath(cwd)\n    try fm.removeItem(at: random_directory)\n    try fm.removeItem(at: URL(fileURLWithPath: dest))\n}\n\nfunc install_app_encrypted(_ params: dynamicParams) throws {\n    let key = params.getKey(\"key\", alternative_method: askUserWrapper(question: \"Asset Key: \"))\n    let appName = params.getKey(\"appName\", alternative_method: askUserWrapper(question: \"App Name: \"))\n    let tempEncZipName = appName + \".zip.enc\"\n    \n    try download_asset([\n        \"key\": key,\n        \"saveName\": tempEncZipName,\n        \"decryptFile\": \"n\"\n    ])\n    \n    guard fm.fileExists(atPath: tempEncZipName) else {\n        throw Errors.fileNotFound(\"Unable to find: \\(tempEncZipName)\")\n    }\n    \n    try install_app_from_encrypted_zip([\n        \"path\": tempEncZipName,\n        \"appName\": appName,\n    ])\n    \n}\n\n#endif\n\nfunc load_password() throws -> String?{\n    if let pw = String(data: try Data(contentsOf: PW_location), encoding: .utf8){\n        return pw\n    }\n    return nil\n}\nfunc decrypt_file(_ filePath: String, file: String){\n    openssl_decrypt(filePath, outputFile: file)\n}\nenum AppFixErrors: Error{\n    case noAppFound\n}\nfunc fixApplication(appURL: URL) throws{\n    let fm = FileManager.default\n    \n    print(\"Checking if \\(appURL.lastPathComponent) is available...\")\n    guard fm.fileExists(atPath: appURL.path) else { throw AppFixErrors.noAppFound }\n    \n    let executables = try fm.contentsOfDirectory(atPath: appURL.path(percentEncoded: false) + \"/Contents/MacOS\")\n    print(\"Executables found:\", executables)\n    \n    let cmds = [\n        [\"xattr\", \"-d\", \"com.apple.quarantine\"],\n        [\"chmod\", \"+x\"],\n        [\"xattr\", \"-cr\"]\n    ]\n    \n    for cmd in cmds{\n        let task = Process()\n        task.executableURL = .init(filePath: \"/usr/bin/env\")\n        task.arguments = cmd + [appURL.path(percentEncoded: false)]\n        try task.run()\n        task.waitUntilExit()\n    }\n    \n    for executable in executables {\n        let fullPath = appURL.path(percentEncoded: false) + \"/Contents/MacOS/\\(executable)\"\n        let task = Process()\n        task.executableURL = .init(filePath: \"/usr/bin/env\")\n        task.arguments = [\"chmod\", \"+x\", fullPath]\n        try task.run()\n        task.waitUntilExit()\n    }\n    \n    \n}\n\nvar COMMANDS: [String: [String: Any]] = [\n    \"get\": [\n        \"function\": get_location,\n        \"description\": \"Get the URL of an asset\"\n    ],\n    \n    \"download\": [\n        \"function\": download_asset,\n        \"description\": \"Download an asset, (optionally decrypting)\"\n    ],\n    \"list\": [\n        \"function\": list_all,\n        \"description\": \"List all available assets\"\n    ],\n    \"update\": [\n        \"function\": update_locations,\n        \"description\": \"Update the CDN with a new asset\"\n    ],\n    \"exit\": [\n        \"function\": exit,\n        \"description\": \"Exit the CLI\"\n    ],\n\n    \"save-password\": [\n        \"function\": save_password,\n        \"description\": \"Save a password to file\"\n    ],\n\n    \"rm-asset\": [\n        \"function\": remove_location,\n        \"description\": \"Remove an asset from the manifest\"\n    ],\n    \"encrypt\": [\n        \"function\": encrypt_asset,\n        \"description\": \"Locally encrypt a file using SDist encryption spec (OpenSSL)\"\n    ],\n\n    \"decrypt\": [\n        \"function\": local_decrypt,\n        \"description\": \"Locally Decrypt a file using SDist encryption spec (OpenSSL)\"\n    ],\n    \n    \"help\": [\n        \"function\": help,\n        \"description\": \"Show this help page\"\n    ],\n    \"clear\": [\n        \"function\": clearScreen,\n        \"description\": \"Clears the screen\"\n    ],\n    \"ls\": [\n        \"function\": listDirectory,\n        \"description\": \"List the contents of a directory\"\n    ]\n]\n\n#if os(macOS)\n// Add Secure Enclave commands (macOS only)\nfunc addMacOSOnly() {\n    COMMANDS[\"encrypt-se\"] = [\n        \"function\": encrypt_asset_se,\n        \"description\": \"Encrypt a file using Secure Enclave (macOS only)\"\n    ]\n    COMMANDS[\"decrypt-se\"] = [\n        \"function\": decrypt_asset_se,\n        \"description\": \"Decrypt a Secure Enclave encrypted file (macOS only)\"\n    ]\n    COMMANDS[\"list-se-keys\"] = [\n        \"function\": list_se_keys,\n        \"description\": \"List Secure Enclave keys in keychain (macOS only)\"\n    ]\n    COMMANDS[\"cleanup-se-keys\"] = [\n        \"function\": cleanup_se_keys,\n        \"description\": \"Clean up old SE key storage (run if having issues)\"\n    ]\n    COMMANDS[\"install\"] = [\n        \"function\": install_app,\n        \"description\": \"Install an application\"\n    ]\n    \n    COMMANDS[\"install-encrypted\"] = [\n        \"function\": install_app_encrypted,\n        \"description\": \"Install an application thats encrypted with OpenSSL\"\n    ]\n    \n    COMMANDS[\"install-local-encrypted\"] = [\n        \"function\": install_app_from_encrypted_zip,\n        \"description\": \"Install an application from a locally encrypted zip\"\n    ]\n}\n#endif\n\n\nfunc showDocumentation(docs: String) {\n    let task = Process()\n    task.launchPath = \"/usr/bin/less\"\n    task.arguments = [docs]\n    try! task.run()\n    task.waitUntilExit()\n}\n\nfunc generateDocs() -> String{\n    var docs = \"SDist â€“ Tool that allows access to asset's stored within the distrubution network.\\n\\n\"\n    \n    docs += \"Flags for command line mode:\\n\"\n    for flag in documentationForFlags{\n        docs += \"\\(flag.key): \\(flag.value)\" + \"\\n\"\n    }\n    \n    docs += \"\\nYou can find the number/kind of arguments a command takes by running the command in the regular mode.\\n\\n\"\n    docs += \"Commands:\\n\"\n    \n    for command in COMMANDS{\n        docs += \" \\(command.key): \\(command.value[\"description\"]!)\" + \"\\n\"\n    }\n    \n    docs += \"\\n\\nExample usage:\\n\"\n    docs += \"./this_file -c -p PASSWORD -f get -a ASSET_KEY\\n\"\n    \n    \n    return docs\n}\n"
main.swift: "//\n//  main.swift\n//  SDist\n//\n//  Created by Sal Faris on 27/02/2024.\n//\n\nimport Foundation\n\n\n\nlet VERSION = 0.8\n\nprint(WELCOME_MSG)\nprint(\"Version: \\(VERSION)\")\n\nextension String{\n    func startswith(_ string: String) -> Bool{\n        return self.hasPrefix(string)\n    }\n    \n    \n    func format(arguments: [CVarArg]) -> String{\n        let string = String(format: self, arguments: arguments)\n        return string\n    }\n}\n\nextension [String]{\n    func contains(_ string: String) -> Bool{\n        return self.contains { str in\n            str == string\n        }\n    }\n    func contains(_ cliArg: CommandLineArgs) -> Bool{\n        return self.contains(cliArg.rawValue)\n    }\n    func findArgumentValue(_ cliArgs: CommandLineArgs) throws -> String{\n        if let index = self.firstIndex(of: cliArgs.rawValue){\n            if (index + 1) < self.count{\n                return self[index + 1]\n            }else{\n                print(\"Unable to find a value for: \\(cliArgs.rawValue)\")\n                throw CLIExceptions.MissingArguments\n            }\n        }else{\n            print(\"Unable to find index for: \\(cliArgs.rawValue)\")\n            throw CLIExceptions.MissingArguments\n        }\n        \n        \n    }\n    func findArgumentValues(_ cliArgs: CommandLineArgs) -> [String]{\n        if let index = self.firstIndex(of: cliArgs.rawValue){\n            if (index + 1) < self.count{\n                return [String](self.suffix(from: index + 1))\n            }\n        }\n        \n        return []\n    }\n}\n\n\n\nvar PASSWORD: String = \"NONE\"\nlet arguments = CommandLine.arguments\nlet PW_location = URL(fileURLWithPath: FileManager.default.currentDirectoryPath).appendingPathComponent(\".sdist\")\n\n// Initialize Secure Enclave commands on macOS\n#if os(macOS)\n//se_check_biometry()\naddMacOSOnly()\n#endif\n\n\n\nfunc user_interface() throws{\n    help(dynamicParams())\n    while true{\n        print(\"Ener a command: \", terminator: \"\")\n        let cmd = readLine()!\n        \n        if cmd == \"exit\"{\n            exit(EXIT_SUCCESS)\n        }\n        \n        if let command = COMMANDS[cmd]{\n            guard let function = command[\"function\"]! as? (dynamicParams) throws -> Void else {\n                throw CLIExceptions.UnableToCastFunction\n            }\n            \n            let showOperation = String(repeating: \"*\", count: Int(Double(getTerminalColumns() ?? 100) * 0.5))\n            print(showOperation)\n            try function(.init())\n            if cmd != \"clear\"{ print(showOperation) }\n        }\n    }\n}\n\nfunc commandLineMode() throws{\n    let function = try arguments.findArgumentValue(.functionArg)\n    let args = arguments.findArgumentValues(.argumentsArg)\n    \n    print(\"Function: \\(function)\")\n    print(\"Args: \\(args)\")\n    \n    if let cmd = COMMANDS[function]{\n        guard let function = cmd[\"function\"]! as? (dynamicParams) throws -> Void else { throw CLIExceptions.UnableToCastFunction }\n        if args.count > 0{\n            try function(.init(fromArray: args))\n        }else{\n            try function(.init())\n        }\n    }\n}\n\n\n\ndo{\n    // check if the help message arg was passed\n    if arguments.contains(.helpArg){\n        print(\"Generating docs...\")\n        let docs = generateDocs()\n        print(docs)\n        exit(EXIT_SUCCESS)\n    }\n    \n    if arguments.contains(.cliPathArg){\n        print(arguments)\n    }\n    \n    if arguments.contains(.commandLineMode){\n        if let pw = try? load_password(){\n            PASSWORD = pw\n        }else{\n            PASSWORD = try arguments.findArgumentValue(.passwordArg)\n        }\n        try commandLineMode()\n    }else{\n        if let pw = try? load_password(){\n            PASSWORD = pw\n        }else{\n            PASSWORD = askUser(question: \"Enter Password:\")\n        }\n        try user_interface()\n    }\n    \n} catch {\n    print(\"Error: \\(error)\")\n    exit(EXIT_FAILURE)\n}\n\n\n\n"